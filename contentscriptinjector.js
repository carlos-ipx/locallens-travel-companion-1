(function() { // Added opening for IIFE

  const SIDEBAR_ID = 'locallens-sidebar';
  const SIDEBAR_CSS_ID = 'locallens-sidebar-css';
  let lastUrl = location.href;

  function injectCSS() {
    if (document.getElementById(SIDEBAR_CSS_ID)) return;
    const link = document.createElement('link');
    link.id = SIDEBAR_CSS_ID;
    link.rel = 'stylesheet';
    link.type = 'text/css';
    // Assuming the sidebar specific CSS is 'styles/sidebar.css' as per manifest discussions
    link.href = chrome.runtime.getURL('styles/sidebar.css'); 
    document.head.appendChild(link);
  }

  function createSidebar() {
    injectCSS();
    const existing = document.getElementById(SIDEBAR_ID);
    if (existing) {
      existing.style.display = 'block'; // Ensure it's visible if it already exists
      return existing;
    }
    const container = document.createElement('div');
    container.id = SIDEBAR_ID;
    container.className = 'locallens-sidebar'; // Make sure this class is defined in your sidebar.css
    container.innerHTML = ''
      + '<div class="locallens-sidebar-header">'
      +   '<span class="locallens-title">LocalLens</span>'
      +   '<button class="locallens-close-btn" title="Close">Ã—</button>'
      + '</div>'
      + '<div class="locallens-sidebar-content">Loading...</div>';
    document.body.appendChild(container);
    const btn = container.querySelector('.locallens-close-btn');
    if (btn) {
      btn.addEventListener('click', () => {
        container.style.display = 'none';
      });
    }
    return container;
  }

  function sanitizeHTML(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    // Remove potentially harmful elements
    doc.querySelectorAll('script, iframe, object, embed, link[rel="stylesheet"], style').forEach(el => el.remove());
    // Optionally, you might want to strip event handlers from attributes too, 
    // but that's more complex. For HTML generated by your extension, this might be sufficient.
    return doc.body.innerHTML;
  }

  function updateSidebar(payload) {
    const sidebar = document.getElementById(SIDEBAR_ID) || createSidebar();
    if (!sidebar) return; // Should not happen if createSidebar works

    const content = sidebar.querySelector('.locallens-sidebar-content');
    if (!content) return; // Should not happen if sidebar HTML is correct

    if (payload.html) {
      try {
        content.innerHTML = sanitizeHTML(payload.html);
      } catch (e) {
        content.textContent = 'Failed to render content.';
        console.error('LocalLens: sanitizeHTML error or error setting innerHTML', e);
      }
    } else if (payload.data) {
      try {
        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(payload.data, null, 2);
        content.innerHTML = ''; // Clear previous content
        content.appendChild(pre);
      } catch (e) {
        content.textContent = 'Failed to display data.';
        console.error('LocalLens: render data error', e);
      }
    } else {
      // Handle cases where payload might be empty or not have html/data
      content.textContent = 'No content to display.';
    }
    sidebar.style.display = 'block';
  }

  function ensureSidebar() {
    // Check if the sidebar should be active on this page/URL
    // For now, let's assume it should always be ensured if the script runs.
    // You might add logic here to check against a list of active domains/paths.
    if (!document.getElementById(SIDEBAR_ID)) {
      createSidebar();
    } else {
      // If it exists but is hidden, maybe show it? Or let updates handle visibility.
      // For now, let createSidebar handle making it visible if it re-finds it.
      const sidebar = document.getElementById(SIDEBAR_ID);
      if (sidebar && sidebar.style.display === 'none') {
         // Optionally, decide if merely navigating should re-show a hidden sidebar.
         // For now, we'll let explicit 'updateSidebar' calls handle visibility.
      }
    }
  }

  function handleUrlChange() {
    const currentUrl = location.href;
    if (currentUrl !== lastUrl) {
      console.log('LocalLens: URL changed from', lastUrl, 'to', currentUrl);
      lastUrl = currentUrl;
      // It's generally good to ensure the sidebar exists or is in a known state on navigation.
      // However, also consider if the new URL should even have a sidebar.
      ensureSidebar(); 
      // Send message to background script about navigation
      chrome.runtime.sendMessage({ type: 'pageNavigated', url: currentUrl }, response => {
        if (chrome.runtime.lastError) {
          console.warn('LocalLens: Error sending pageNavigated message:', chrome.runtime.lastError.message);
        } else if (response) {
          console.log('LocalLens: pageNavigated message acknowledged:', response);
        }
      });
    }
  }

  // Monitor URL changes for SPAs
  window.addEventListener('popstate', handleUrlChange);
  window.addEventListener('hashchange', handleUrlChange);

  const originalPushState = history.pushState;
  history.pushState = function() {
    const result = originalPushState.apply(this, arguments);
    window.dispatchEvent(new Event('pushstate')); // Custom event for pushState
    handleUrlChange(); // Or directly call handleUrlChange
    return result;
  };

  const originalReplaceState = history.replaceState;
  history.replaceState = function() {
    const result = originalReplaceState.apply(this, arguments);
    window.dispatchEvent(new Event('replacestate')); // Custom event for replaceState
    handleUrlChange(); // Or directly call handleUrlChange
    return result;
  };

  // Listener for messages from the background script
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request && request.type === 'updateSidebar') {
      console.log('LocalLens: Received updateSidebar message', request.payload);
      updateSidebar(request.payload || {});
      sendResponse({ status: 'ok', received: true });
      return true; // Indicates you wish to send a response asynchronously (or synchronously)
    }
    // Return true for other message types if you plan to sendResponse asynchronously.
    // Otherwise, it's not strictly necessary if you don't sendResponse.
  });

  // Initial check to ensure sidebar is present when script loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureSidebar);
  } else {
    ensureSidebar();
  }

  console.log('LocalLens: Sidebar injector and updater script loaded.');

})(); // Closing for IIFE
